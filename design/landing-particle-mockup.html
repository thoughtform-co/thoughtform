<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Thoughtform │ Particle System Mockup</title>
  
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    body {
      background: #050504;
      color: #ebe3d6;
      font-family: 'PT Mono', ui-monospace, monospace;
      overflow-x: hidden;
      -webkit-font-smoothing: antialiased;
    }
    
    .space-background {
      position: fixed;
      inset: 0;
      z-index: 0;
      pointer-events: none;
    }
    
    .space-canvas {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
    }
    
    .content {
      position: relative;
      z-index: 10;
      min-height: 100vh;
      padding: 120px 24px;
    }
    
    .hero {
      max-width: 800px;
      margin: 0 auto;
      text-align: center;
    }
    
    .hero h1 {
      font-size: clamp(32px, 8vw, 72px);
      font-weight: 300;
      letter-spacing: -0.02em;
      margin-bottom: 24px;
      color: #ebe3d6;
    }
    
    .hero p {
      font-size: 18px;
      line-height: 1.6;
      color: rgba(236, 227, 214, 0.7);
      max-width: 600px;
      margin: 0 auto 48px;
    }
    
    .info {
      position: fixed;
      bottom: 24px;
      left: 24px;
      font-size: 11px;
      color: rgba(236, 227, 214, 0.4);
      font-family: 'PT Mono', monospace;
      z-index: 20;
    }
    
    .scroll-indicator {
      position: fixed;
      top: 24px;
      right: 24px;
      font-size: 11px;
      color: rgba(236, 227, 214, 0.4);
      font-family: 'PT Mono', monospace;
      z-index: 20;
    }
  </style>
</head>
<body>
  <div class="space-background">
    <canvas id="particleCanvas" class="space-canvas"></canvas>
  </div>
  
  <div class="content">
    <div class="hero">
      <h1>Navigate Intelligence</h1>
      <p>
        Thoughtform's particle system creates a 3D space navigation experience 
        using HTML5 Canvas. Scroll to travel through the manifold.
      </p>
    </div>
    
    <!-- Spacer sections to enable scrolling -->
    <div style="height: 200vh; padding: 40px 24px;">
      <div style="max-width: 800px; margin: 0 auto;">
        <h2 style="font-size: 32px; margin-bottom: 24px; font-weight: 300;">Manifold Terrain</h2>
        <p style="line-height: 1.8; color: rgba(236, 227, 214, 0.6); margin-bottom: 48px;">
          The manifold is a wave-based terrain system that creates an atmospheric, 
          navigable space. Particles follow terrain elevation calculated using 
          sine waves and mountain ranges.
        </p>
        
        <h2 style="font-size: 32px; margin-bottom: 24px; font-weight: 300; margin-top: 120px;">Gateway Portal</h2>
        <p style="line-height: 1.8; color: rgba(236, 227, 214, 0.6); margin-bottom: 48px;">
          The gateway portal appears in the hero section, fading out as you scroll. 
          It's rendered using concentric rings and spiral patterns.
        </p>
        
        <h2 style="font-size: 32px; margin-bottom: 24px; font-weight: 300; margin-top: 120px;">Landmarks</h2>
        <p style="line-height: 1.8; color: rgba(236, 227, 214, 0.6); margin-bottom: 48px;">
          Landmarks appear at different scroll sections. The Lorenz Attractor 
          (gold) appears in the definition section, floating above the terrain.
        </p>
      </div>
    </div>
  </div>
  
  <div class="info">
    Thoughtform.co │ Particle System Mockup
  </div>
  
  <div class="scroll-indicator">
    Scroll: <span id="scrollProgress">0.0%</span>
  </div>

  <script>
    // ═══════════════════════════════════════════════════════════════
    // PARTICLE SYSTEM - Ported from ParticleCanvasV2
    // ═══════════════════════════════════════════════════════════════
    
    const GRID = 3;
    
    // Grid snapping
    function snap(value) {
      return Math.floor(value / GRID) * GRID;
    }
    
    // Convert hex to RGB string
    function hexToRgb(hex) {
      const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
      if (!result) return "236, 227, 214";
      return `${parseInt(result[1], 16)}, ${parseInt(result[2], 16)}, ${parseInt(result[3], 16)}`;
    }
    
    // Draw pixel (grid-snapped square)
    function drawPixel(ctx, x, y, color, alpha, size = GRID) {
      const px = snap(x);
      const py = snap(y);
      ctx.fillStyle = `rgba(${color}, ${alpha})`;
      ctx.fillRect(px, py, size - 1, size - 1);
    }
    
    // Desaturate by depth
    function desaturateByDepth(rgbString, depth, intensity = 0.8) {
      const parts = rgbString.split(",").map(s => parseInt(s.trim()));
      if (parts.length !== 3) return rgbString;
      
      const [r, g, b] = parts;
      const targetGray = { r: 35, g: 33, b: 30 };
      const blendFactor = Math.min(1, depth * intensity);
      
      const newR = Math.round(r + (targetGray.r - r) * blendFactor);
      const newG = Math.round(g + (targetGray.g - g) * blendFactor);
      const newB = Math.round(b + (targetGray.b - b) * blendFactor);
      
      return `${newR}, ${newG}, ${newB}`;
    }
    
    // Particle structure
    class Particle {
      constructor(x, y, z, type, color, landmark, landmarkId) {
        this.x = x;
        this.y = y;
        this.z = z;
        this.baseX = x;
        this.baseY = y;
        this.type = type; // "terrain" | "gateway" | "geo" | "star"
        this.color = color;
        this.size = 1 + Math.random() * 0.5;
        this.phase = Math.random() * Math.PI * 2;
        this.landmark = landmark;
        this.landmarkId = landmarkId;
      }
    }
    
    // Terrain height calculation
    function getTerrainY(x, z, config) {
      const clampedZ = Math.max(800, Math.min(8800, z));
      const r = (clampedZ - 800) / 50;
      const c = x / 65 + 35;
      
      const wavePhase = r * 0.02;
      let y = 400 +
        Math.sin(c * config.waveFrequency + wavePhase) * config.waveAmplitude +
        Math.cos(r * 0.12) * 150 +
        Math.sin(c * 0.35 + r * 0.15) * 70 +
        Math.sin(r * 0.08) * 100;
      
      // Mountain range in far background
      const mountainStart = 100;
      if (r > mountainStart) {
        const mountainProgress = (r - mountainStart) / (config.rows - mountainStart);
        const maxMountainHeight = 400;
        const mountainHeight = mountainProgress * maxMountainHeight;
        
        const peakFreq1 = 0.08;
        const peakFreq2 = 0.15;
        const peakFreq3 = 0.03;
        
        const peak1 = Math.pow(Math.max(0, Math.sin(c * peakFreq1 + 1.5)), 2) * mountainHeight;
        const peak2 = Math.pow(Math.max(0, Math.sin(c * peakFreq2 + 0.8)), 2) * mountainHeight * 0.6;
        const peak3 = Math.pow(Math.max(0, Math.sin(c * peakFreq3)), 1.5) * mountainHeight * 0.8;
        
        y -= (peak1 + peak2 + peak3) * 0.7;
      }
      
      return y;
    }
    
    // Generate gateway shape
    function generateGatewayShape(particles, landmark, index, manifoldConfig) {
      const colorRgb = hexToRgb(landmark.color);
      const scale = landmark.scale;
      const density = landmark.density;
      const baseX = landmark.position.x;
      const baseZ = landmark.position.z;
      const radius = 400 * scale;
      
      // Concentric rings
      const ringCount = Math.floor(8 * density);
      for (let ring = 0; ring < ringCount; ring++) {
        const ringRadius = radius - ring * (20 * scale);
        const points = Math.max(20, Math.floor((80 - ring * 5) * density));
        const z = baseZ + ring * 15;
        
        for (let i = 0; i < points; i++) {
          const angle = (i / points) * Math.PI * 2;
          const x = baseX + Math.cos(angle) * ringRadius;
          const y = landmark.position.y + Math.sin(angle) * ringRadius;
          particles.push(new Particle(x, y, z, "gateway", colorRgb, index, landmark.id));
        }
      }
      
      // Inner spiral
      const spiralPoints = Math.floor(150 * density);
      for (let i = 0; i < spiralPoints; i++) {
        const t = i / spiralPoints;
        const angle = t * Math.PI * 2 * 5;
        const spiralRadius = (1 - t) * radius * 0.9;
        const z = baseZ + 100 + t * 600;
        const x = baseX + Math.cos(angle) * spiralRadius;
        const y = landmark.position.y + Math.sin(angle) * spiralRadius * 0.8;
        particles.push(new Particle(x, y, z, "gateway", colorRgb, index, landmark.id));
      }
      
      // Core glow
      const corePoints = Math.floor(60 * density);
      for (let i = 0; i < corePoints; i++) {
        const angle = Math.random() * Math.PI * 2;
        const dist = Math.random() * 80 * scale;
        const x = baseX + Math.cos(angle) * dist;
        const y = landmark.position.y + Math.sin(angle) * dist;
        const z = baseZ + 50 + Math.random() * 100;
        particles.push(new Particle(x, y, z, "gateway", colorRgb, index, landmark.id));
      }
    }
    
    // Generate Lorenz attractor
    function generateLorenzShape(particles, landmark, index, manifoldConfig) {
      const colorRgb = hexToRgb(landmark.color);
      const scale = landmark.scale;
      const density = landmark.density;
      const centerX = landmark.position.x;
      const baseY = landmark.position.y || 200;
      const centerZ = landmark.position.z;
      
      // Lorenz system parameters
      const sigma = 10;
      const rho = 28;
      const beta = 8 / 3;
      const dt = 0.005;
      
      const numPoints = Math.floor(3000 * density);
      const visualScale = 12 * scale;
      
      // Starting point
      let x = 0.1, y = 0, z = 0;
      
      for (let i = 0; i < numPoints; i++) {
        // Lorenz equations
        const dx = sigma * (y - x);
        const dy = x * (rho - z) - y;
        const dz = x * y - beta * z;
        
        x += dx * dt;
        y += dy * dt;
        z += dz * dt;
        
        // Map attractor coordinates to world space
        const worldX = centerX + x * visualScale;
        const worldY = baseY - z * visualScale * 0.5; // Z becomes height (inverted)
        const worldZ = centerZ + y * visualScale * 0.4; // Y becomes depth (compressed)
        
        particles.push(new Particle(worldX, worldY, worldZ, "geo", colorRgb, index, landmark.id));
      }
    }
    
    // Initialize particles
    function initParticles(config) {
      const particles = [];
      const { manifold, landmarks } = config;
      
      const manifoldColorRgb = hexToRgb(manifold.color);
      
      // Terrain
      const terrainRows = Math.max(manifold.rows, 220);
      const terrainColumns = manifold.columns;
      
      for (let r = 0; r < terrainRows; r++) {
        for (let c = 0; c < terrainColumns; c++) {
          const x = (c - terrainColumns / 2) * (70 * manifold.spreadX);
          const z = 200 + r * (55 * manifold.spreadZ);
          
          const wavePhase = r * 0.02;
          let y = 400 +
            Math.sin(c * manifold.waveFrequency + wavePhase) * manifold.waveAmplitude +
            Math.cos(r * 0.12) * 150 +
            Math.sin(c * 0.35 + r * 0.15) * 70 +
            Math.sin(r * 0.08) * 100;
          
          // Mountain range
          const mountainStart = 100;
          if (r > mountainStart) {
            const mountainProgress = (r - mountainStart) / (terrainRows - mountainStart);
            const maxMountainHeight = 400;
            const mountainHeight = mountainProgress * maxMountainHeight;
            
            const peakFreq1 = 0.08;
            const peakFreq2 = 0.15;
            const peakFreq3 = 0.03;
            
            const peak1 = Math.pow(Math.max(0, Math.sin(c * peakFreq1 + 1.5)), 2) * mountainHeight;
            const peak2 = Math.pow(Math.max(0, Math.sin(c * peakFreq2 + 0.8)), 2) * mountainHeight * 0.6;
            const peak3 = Math.pow(Math.max(0, Math.sin(c * peakFreq3)), 1.5) * mountainHeight * 0.8;
            
            y -= (peak1 + peak2 + peak3) * 0.7;
            y -= Math.random() * mountainHeight * 0.1;
          }
          
          particles.push(new Particle(x, y, z, "terrain", manifoldColorRgb, 0));
        }
      }
      
      // Landmarks
      landmarks.forEach((landmark, index) => {
        if (!landmark.enabled) return;
        
        // Use section number if provided, otherwise use index + 1
        const landmarkSection = landmark.section !== undefined ? landmark.section : index + 1;
        
        switch (landmark.shape) {
          case "gateway":
            generateGatewayShape(particles, landmark, landmarkSection, manifold);
            break;
          case "lorenz":
            generateLorenzShape(particles, landmark, landmarkSection, manifold);
            break;
        }
      });
      
      // Sort by depth (far to near)
      particles.sort((a, b) => b.z - a.z);
      return particles;
    }
    
    // ═══════════════════════════════════════════════════════════════
    // RENDERER
    // ═══════════════════════════════════════════════════════════════
    
    const canvas = document.getElementById('particleCanvas');
    const ctx = canvas.getContext('2d');
    
    let particles = [];
    let scrollProgress = 0;
    let time = 0;
    let animationId = 0;
    
    // Config (matching defaults from particle-config.ts)
    const config = {
      manifold: {
        color: "#3a3832",
        rows: 140,
        columns: 60,
        waveAmplitude: 180,
        waveFrequency: 0.2,
        spreadX: 1.0,
        spreadZ: 1.0,
        opacity: 0.35,
      },
      landmarks: [
        {
          id: "gateway",
          shape: "gateway",
          color: "#d4ccc0",
          density: 1.5,
          scale: 1.0,
          position: { x: 150, y: 180, z: 800 },
          enabled: true,
          section: 1, // Hero section
        },
        {
          id: "lorenz",
          shape: "lorenz",
          color: "#caa554",
          density: 1.5,
          scale: 1.2,
          position: { x: 0, y: 0, z: 2400 },
          enabled: true,
          section: 2, // Definition section
        },
      ],
      camera: {
        focalLength: 400,
        vanishX: 0.5,
        vanishY: 0.5,
        pitch: 0,
        yaw: 0,
        roll: 0,
        truckX: 0,
        truckY: 0,
        terrainClipY: 0.35,
        maxDepth: 12000,
      },
    };
    
    // Resize handler
    function resize() {
      const dpr = Math.min(window.devicePixelRatio || 1, 2);
      const width = window.innerWidth;
      const height = window.innerHeight;
      
      canvas.width = width * dpr;
      canvas.height = height * dpr;
      canvas.style.width = width + 'px';
      canvas.style.height = height + 'px';
      
      ctx.scale(dpr, dpr);
    }
    
    // Scroll handler
    function updateScrollProgress() {
      const scrollHeight = document.documentElement.scrollHeight - window.innerHeight;
      scrollProgress = scrollHeight > 0 ? window.scrollY / scrollHeight : 0;
      scrollProgress = Math.min(1, Math.max(0, scrollProgress));
      
      document.getElementById('scrollProgress').textContent = (scrollProgress * 100).toFixed(1) + '%';
    }
    
    // Render loop
    function render() {
      const width = canvas.width / (window.devicePixelRatio || 1);
      const height = canvas.height / (window.devicePixelRatio || 1);
      
      if (width === 0 || height === 0) {
        animationId = requestAnimationFrame(render);
        return;
      }
      
      const scrollZ = scrollProgress * 9000;
      const currentSection = Math.floor(scrollProgress * 4) + 1;
      const sectionProgress = (scrollProgress * 4) % 1;
      
      // Clear
      ctx.fillStyle = "#050504";
      ctx.fillRect(0, 0, width, height);
      
      // Camera settings
      const camera = config.camera;
      const MAX_DEPTH = camera.maxDepth;
      const FOCAL = camera.focalLength;
      const cx_geo = width * camera.vanishX;
      const cy = height * camera.vanishY;
      
      const pitchRad = (camera.pitch * Math.PI) / 180;
      const yawRad = (camera.yaw * Math.PI) / 180;
      const rollRad = (camera.roll * Math.PI) / 180;
      const cosPitch = Math.cos(pitchRad);
      const sinPitch = Math.sin(pitchRad);
      const cosYaw = Math.cos(yawRad);
      const sinYaw = Math.sin(yawRad);
      const cosRoll = Math.cos(rollRad);
      const sinRoll = Math.sin(rollRad);
      
      // Render particles
      for (let i = 0; i < particles.length; i++) {
        const p = particles[i];
        let relZ;
        let particleAlpha = 1;
        let terrainAlphaMultiplier = 1;
        
        if (p.type === "terrain") {
          relZ = p.z - scrollZ;
          terrainAlphaMultiplier = config.manifold.opacity;
        } else if (p.type === "gateway") {
          relZ = p.z - scrollZ;
          if (scrollProgress > 0.15) {
            particleAlpha = Math.max(0, 1 - (scrollProgress - 0.15) * 4);
          }
        } else {
          relZ = p.z - scrollZ;
          
          if (p.landmark) {
            const landmarkSection = p.landmark;
            const sectionDist = Math.abs(currentSection - landmarkSection);
            
            if (sectionDist === 0) {
              particleAlpha = 1;
              const emergence = Math.min(1, sectionProgress * 1.8);
              particleAlpha *= emergence;
            } else if (sectionDist === 1) {
              particleAlpha = 0.3;
            } else {
              particleAlpha = 0;
              continue;
            }
          }
        }
        
        // Culling
        if (p.type === "terrain") {
          if (relZ <= 30 || relZ > MAX_DEPTH) continue;
        } else {
          if (relZ <= 5 || relZ > MAX_DEPTH) continue;
        }
        
        // Breathing animation
        const breatheX = Math.sin(time * 0.015 + p.phase) * 5;
        const breatheY = Math.cos(time * 0.012 + p.phase * 1.3) * 4;
        
        // World position
        let worldX = p.x + breatheX - camera.truckX;
        let worldZ = relZ;
        
        // Apply yaw rotation
        const rotX = worldX * cosYaw - worldZ * sinYaw;
        const rotZ = worldX * sinYaw + worldZ * cosYaw;
        worldX = rotX;
        worldZ = rotZ;
        
        if (worldZ <= 5) continue;
        
        // Perspective projection
        const scale = FOCAL / worldZ;
        const pitchFactor = cosPitch;
        const worldY = (p.y + breatheY - camera.truckY) * pitchFactor;
        
        // Screen position before roll
        const preRollX = cx_geo + worldX * scale;
        const preRollY = cy + worldY * scale - sinPitch * 150 * scale;
        
        // Apply roll
        const dx = preRollX - cx_geo;
        const dy = preRollY - cy;
        const x = cx_geo + dx * cosRoll - dy * sinRoll;
        const y = cy + dx * sinRoll + dy * cosRoll;
        
        // Bounds check
        if (p.type === "terrain") {
          if (x < -150 || x > width + 150 || y < -150 || y > height + 150) continue;
          if (camera.terrainClipY > 0 && y < height * camera.terrainClipY) continue;
        } else {
          if (x < -50 || x > width + 50 || y < -50 || y > height + 50) continue;
        }
        
        // Depth-based alpha
        const normalizedDepth = worldZ / MAX_DEPTH;
        const depthAlpha = Math.min(1, (1 - normalizedDepth) * 1.2 + 0.2);
        const proximityBoost = worldZ < 1500 ? 1 + (1 - worldZ / 1500) * 0.3 : 1;
        const breatheAlpha = 0.9 + Math.sin(time * 0.015 + p.phase) * 0.1;
        const finalAlpha = Math.min(1, depthAlpha * particleAlpha * terrainAlphaMultiplier * breatheAlpha * proximityBoost);
        
        // Desaturate by depth
        const desaturatedColor = desaturateByDepth(p.color, normalizedDepth, 0.85);
        
        // Draw
        if (p.type === "terrain") {
          const sizeMultiplier = Math.min(2.5, 0.6 + scale * 1.2);
          const size = Math.max(GRID, GRID * sizeMultiplier);
          const distanceBlur = normalizedDepth > 0.4 ? (normalizedDepth - 0.4) * 2 : 0;
          const blurredSize = size + distanceBlur * 3;
          const atmosphericFade = Math.pow(normalizedDepth, 0.6);
          const blurredAlpha = finalAlpha * (1 - atmosphericFade * 0.7) * (1 - distanceBlur * 0.2);
          
          drawPixel(ctx, x, y, desaturatedColor, blurredAlpha, blurredSize);
          
          if (normalizedDepth < 0.15 && finalAlpha > 0.4) {
            const bloomAlpha = blurredAlpha * 0.08;
            drawPixel(ctx, x, y, desaturatedColor, bloomAlpha, blurredSize * 2);
          }
        } else {
          const baseSize = p.type === "gateway" ? GRID * 2 : GRID * 1.6;
          const size = Math.max(GRID, baseSize * Math.min(3, scale * 2));
          const landmarkAtmosphericFade = Math.pow(normalizedDepth, 0.8);
          const landmarkAlpha = finalAlpha * (1 - landmarkAtmosphericFade * 0.5);
          
          drawPixel(ctx, x, y, p.color, landmarkAlpha, size);
          
          if (p.type === "gateway" && scale > 0.6 && particleAlpha > 0.5) {
            const glowPulse = Math.sin(time * 0.03 + p.phase) * 0.25 + 0.5;
            if (glowPulse > 0.3 && normalizedDepth < 0.3) {
              drawPixel(ctx, x, y, p.color, landmarkAlpha * 0.08 * glowPulse, GRID * 4);
            }
          }
        }
      }
      
      time += 0.016; // ~60fps
      animationId = requestAnimationFrame(render);
    }
    
    // Initialize
    resize();
    particles = initParticles(config);
    updateScrollProgress();
    render();
    
    // Event listeners
    window.addEventListener('resize', resize);
    window.addEventListener('scroll', updateScrollProgress, { passive: true });
  </script>
</body>
</html>

